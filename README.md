# RustText
# 第一阶段：学习rust
## 7月5日
把项目clone到clion上面，看了一下rust相关的书籍
## 7月6日
### 了解rust语法：
```rust

fn main(){} Rust程序入口函数，目前无返回值
let a = 10; 使用let声明变量，进行绑定，a不可变，
            没有指定a的类型，编译器会默认根据a的值为a推断a的类型为i32,
            结尾用分号结束
let b:i32 = 20;  主动指定b的类型为i32(有符号32位整数)
let mut c =  30i32;   值是32，类型是查i32
                       c 是可变的，mutable
let  d = 30_i32; 可读性会更好
let  e = add(add(a,b),add(c,d));使用一个函数的返回值，作为另一个函数的参数；
println!("(a+b)+(c+d)={}",e);    println!是宏调用，返回的是宏定义的代码块
                                该函数将指定的格式化字符串输出到标准输出中（控制台）
                                {}是占位符，执行过程中，会把e的值带入进来。
定义函数
fn add(i:i32,j:i32)->i32{
i+j//可以省略return
}
字符串使用双引号 "" 而不是单引号 ''，Rust 中单引号是留给单个字符类型（char）使用的
Rust 使用 {} 来作为格式化输出占位符，其它语言可能使用的是 %s，%d，%p 等，由于 println! 会自动推导出具体的类型，因此无需手动指定
### 变量命名
和其他语言一样，不要使用关键字，后面会依次补充关键字
### 变量绑定
let a = "hello world";这个过程就叫变量绑定（涉及到rust核心原则之一----所有权。任何内存对象都是有主人的，在一般情况下，是完全属于它的主人，绑定就是把这个对象绑定给一个变量，让这个变量成为它的主人。）
### 使用下划线开头忽略未使用的变量。
比如你刚开始一个项目，无法确定此变量会不会使用，可以用下划线作为变量名的开头，告诉rust不要警告未使用的变量
let _x = 5;
### 变量解构
let 不仅用于变量的绑定，还能进行复杂的解构。
```rust
fn main(){
let (a,mut b):(bool,bool) = (ture,false);//a = true,不可变，b = false ，可变
println!("a ={:?},b={:?}",a,b);
b = true;
assert_eq!(a,b);
运行结果：a = true, b = false
}
### 解构式赋值
```rust
struct Struct{
e :i32
}
fn main(){
 let (a, b, c, d, e);
    (a, b) = (1, 2);
    // _ 代表匹配一个值，但是我们不关心具体的值是什么，因此没有是一个变量名而是使用了 _
    [c, .., d, _] = [1, 2, 3, 4, 5];
    Struct { e, .. } = Struct { e: 5 };

    assert_eq!([1, 2, 1, 4, 5], [a, b, c, d, e]);
}
### 常量和变量：
常量不允许使用 mut。常量不仅仅默认不可变，而且自始至终不可变，因为常量在编译完成后，已经确定它的值。
常量使用 const 关键字而不是 let 关键字来声明，并且值的类型必须标注。

常量名为 MAX_POINTS，值设置为 100,000。（Rust 常量的命名约定是全部字母都使用大写，并使用下划线分隔单词，另外对数字字面量可插入下划线以提高可读性）：const MAX_POINTS: u32 = 100_000;

常量可以在任意作用域内声明，包括全局作用域，在声明的作用域内，常量在程序运行的整个过程中都有效。对于需要在多处代码共享一个不可变的值时非常有用

### 变量遮蔽
Rust 允许声明相同的变量名，在后面声明的变量会遮蔽掉前面声明的，
```rust
fn main() {
    let x = 5;
    // 在main函数的作用域内对之前的x进行遮蔽
    let x = x + 1;

    {
        // 在当前的花括号作用域内，对之前的x进行遮蔽
        let x = x * 2;
        println!("The value of x in the inner scope is: {}", x);
    }

    println!("The value of x is: {}", x);
}
这个程序首先将数值 5 绑定到 x，然后通过重复使用 let x = 来遮蔽之前的 x，并取原来的值加上 1，所以 x 的值变成了 6。第三个 let 语句同样遮蔽前面的 x，取之前的值并乘上 2，得到的 x 最终值为 12。
这和 mut 变量的使用是不同的，第二个 let 生成了完全不同的新变量，两个变量只是恰好拥有同样的名称，涉及一次内存对象的再分配 ，而 mut 声明的变量，可以修改同一个内存地址上的值，并不会发生内存对象的再分配，性能要更好。

## 基本类型
分为两个类型：基本类型和复合类型
基本类型：
数值类型: 有符号整数 (i8, i16, i32, i64, isize)、 无符号整数 (u8, u16, u32, u64, usize) 、浮点数 (f32, f64)、以及有理数、复数
字符串：字符串字面量和字符串切片 &str
布尔类型： true和false
字符类型: 表示单个 Unicode 字符，存储为 4 个字节
单元类型: 即 () ，其唯一的值也是 ()
### 数值类型
类型定义的形式统一为：有无符号 + 类型大小(位数)。无符号数表示数字只能取正数，而有符号则表示数字既可以取正数又可以取负数。就像在纸上写数字一样：当要强调符号时，数字前面可以带上正号或负号；然而，当很明显确定数字为正数时，就不需要加上正号了。有符号数字以补码形式存储。
每个有符号类型规定的数字范围是 -(2n - 1) ~ 2n - 1 - 1，其中 n 是该定义形式的位长度。因此 i8 可存储数字范围是 -(27) ~ 27 - 1，即 -128 ~ 127。无符号类型可以存储的数字范围是 0 ~ 2n - 1，所以 u8 能够存储的数字为 0 ~ 28 - 1，即 0 ~ 255。
isize 和 usize 类型取决于程序运行的计算机 CPU 类型： 若 CPU 是 32 位的，则这两个类型是 32 位的，同理，若 CPU 是 64 位，那么它们则是 64 位。
### 整形溢出
假设有一个 u8 ，它可以存放从 0 到 255 的值。那么当你将其修改为范围之外的值，比如 256，则会发生整型溢出。
在当使用 --release 参数进行 release 模式构建时，Rust 不检测溢出。相反，当检测到整型溢出时，Rust 会按照补码循环溢出（two’s complement wrapping）的规则处理。简而言之，大于该类型最大值的数值会被补码转换成该类型能够支持的对应数字的最小值。比如在 u8 的情况下，256 变成 0，257 变成 1，
要显式处理可能的溢出，可以使用标准库针对原始数字类型提供的这些方法：
使用 wrapping_* 方法在所有模式下都按照补码循环溢出规则处理，例如 wrapping_add
如果使用 checked_* 方法时发生溢出，则返回 None 值
使用 overflowing_* 方法返回该值和一个指示是否存在溢出的布尔值
使用 saturating_* 方法使值达到最小值或最大值

### 浮点类型
```rust

fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}

fn main() {
    let abc: (f32, f32, f32) = (0.1, 0.2, 0.3);
    let xyz: (f64, f64, f64) = (0.1, 0.2, 0.3);

    println!("abc (f32)");
    println!("   0.1 + 0.2: {:x}", (abc.0 + abc.1).to_bits());
    println!("         0.3: {:x}", (abc.2).to_bits());
    println!();

    println!("xyz (f64)");
    println!("   0.1 + 0.2: {:x}", (xyz.0 + xyz.1).to_bits());
    println!("         0.3: {:x}", (xyz.2).to_bits());
    println!();

    assert!(abc.0 + abc.1 == abc.2);
    assert!(xyz.0 + xyz.1 == xyz.2);
}
结果：
abc (f32)
   0.1 + 0.2: 3e99999a
         0.3: 3e99999a

xyz (f64)
   0.1 + 0.2: 3fd3333333333334
         0.3: 3fd3333333333333

对 f32 类型做加法时，0.1 + 0.2 的结果是 3e99999a，0.3 也是 3e99999a，因此 f32 下的 0.1 + 0.2 == 0.3 通过测试，但是到了 f64 类型时，结果就不一样了，因为 f64 精度高很多，因此在小数点非常后面发生了一点微小的变化，0.1 + 0.2 以 4 结尾，但是 0.3 以3结尾，这个细微区别导致 f64 下的测试失败了，并且抛出了异常。

出于防御性编程的考虑，可以使用 is_nan() 等方法，可以用来判断一个数值是否是 NaN ：
fn main() {
    let x = (-42.0_f32).sqrt();
    if x.is_nan() {
        println!("未定义的数学行为")
    }
}
```rust
fn main() {
  // 编译器会进行自动推导，给予twenty i32的类型
  let twenty = 20;
  // 类型标注
  let twenty_one: i32 = 21;
  // 通过类型后缀的方式进行类型标注：22是i32类型
  let twenty_two = 22i32;

  // 只有同样类型，才能运算
  let addition = twenty + twenty_one + twenty_two;
  println!("{} + {} + {} = {}", twenty, twenty_one, twenty_two, addition);

  // 对于较长的数字，可以用_进行分割，提升可读性
  let one_million: i64 = 1_000_000;
  println!("{}", one_million.pow(2));

  // 定义一个f32数组，其中42.0会自动被推导为f32类型
  let forty_twos = [
    42.0,
    42f32,
    42.0_f32,
  ];

  // 打印数组中第一个值，并控制小数位为2位
  println!("{:.2}", forty_twos[0]);
}
20 + 21 + 22 = 63
1000000000000
42.00
### 位运算
运算符	说明
& 位与	相同位置均为1时则为1，否则为0
| 位或	相同位置只要有1时则为1，否则为0
^ 异或	相同位置不相同则为1，相同则为0
! 位非	把位中的0和1相互取反，即0置为1，1置为0
<< 左移	所有位向左移动指定位数，右位补零
>> 右移	所有位向右移动指定位数，左位补零
```rust
fn main() {
    // 二进制为00000010
    let a:i32 = 2;
    // 二进制为00000011
    let b:i32 = 3;

    println!("(a & b) value is {}", a & b);

    println!("(a | b) value is {}", a | b);

    println!("(a ^ b) value is {}", a ^ b);

    println!("(!b) value is {} ", !b);

    println!("(a << b) value is {}", a << b);

    println!("(a >> b) value is {}", a >> b);

    let mut a = a;
    // 注意这些计算符除了!之外都可以加上=进行赋值 (因为!=要用来判断不等于)
    a <<= b;
    println!("(a << b) value is {}", a);
}
(a & b) value is 2
(a | b) value is 3
(a ^ b) value is 1
(!b) value is -4 
(a << b) value is 16
(a >> b) value is 0
(a << b) value is 16

###  序列Range
例如 1..5，生成从 1 到 4 的连续数字，不包含 5 ；1..=5，生成从 1 到 5 的连续数字，包含 5

for i in 1..=5 {
    println!("{}",i);
}

1
2
3
4
5
序列只允许用于数字或字符类型，原因是：它们可以连续
for i in 'a'..='z' {
    println!("{}",i);
}

### 有理数和复数
社区已经开发出高质量的 Rust 数值库：num。
按照以下步骤来引入 num 库：
创建新工程 cargo new complex-num && cd complex-num
在 Cargo.toml 中的 [dependencies] 下添加一行 num = "0.4.0"
将 src/main.rs 文件中的 main 函数替换为下面的代码
运行 cargo run
use num::complex::Complex;
 fn main() {
   let a = Complex { re: 2.1, im: -1.2 };
   let b = Complex::new(11.1, 22.2);
   let result = a + b;

   println!("{} + {}i", result.re, result.im)
 }
13.2 + 21i
Rust 拥有相当多的数值类型. 因此你需要熟悉这些类型所占用的字节数，这样就知道该类型允许的大小范围以及你选择的类型是否能表达负数
类型转换必须是显式的. Rust 永远也不会偷偷把你的 16bit 整数转换成 32bit 整数
Rust 的数值上可以使用方法. 例如你可以用以下方法来将 13.14 取整：13.14_f32.round()，在这里我们使用了类型后缀，因为编译器需要知道 13.14 的具体类型

